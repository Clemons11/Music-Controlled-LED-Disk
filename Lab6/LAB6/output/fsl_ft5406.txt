; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_ft5406.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_ft5406.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I"C:\Users\Matt\Documents\PSUEE\EE 403W\Lab6\LAB6\RTE\_Lab6" -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\brd_eval54607\inc -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=522 -D_RTE_ -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_ft5406.crf SRC\System\fsl_ft5406.c]
                          THUMB

                          AREA ||i.FT5406_Denit||, CODE, READONLY, ALIGN=2

                  FT5406_Denit PROC
;;;121    
;;;122    status_t FT5406_Denit(ft5406_handle_t *handle)
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4604              MOV      r4,r0
;;;124        assert(handle);
000004  b104              CBZ      r4,|L1.8|
000006  e004              B        |L1.18|
                  |L1.8|
000008  227c              MOVS     r2,#0x7c
00000a  a105              ADR      r1,|L1.32|
00000c  a00a              ADR      r0,|L1.56|
00000e  f7fffffe          BL       __aeabi_assert
                  |L1.18|
;;;125    
;;;126        if (!handle)
000012  b90c              CBNZ     r4,|L1.24|
;;;127        {
;;;128            return kStatus_InvalidArgument;
000014  2004              MOVS     r0,#4
                  |L1.22|
;;;129        }
;;;130    
;;;131        handle->base = NULL;
;;;132        return kStatus_Success;
;;;133    }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  2000              MOVS     r0,#0                 ;131
00001a  6020              STR      r0,[r4,#0]            ;131
00001c  bf00              NOP                            ;132
00001e  e7fa              B        |L1.22|
;;;134    
                          ENDP

                  |L1.32|
000020  5352435c          DCB      "SRC\\System\\fsl_ft5406.c",0
000024  53797374
000028  656d5c66
00002c  736c5f66
000030  74353430
000034  362e6300
                  |L1.56|
000038  68616e64          DCB      "handle",0
00003c  6c6500  
00003f  00                DCB      0

                          AREA ||i.FT5406_GetMultiTouch||, CODE, READONLY, ALIGN=1

                  FT5406_GetMultiTouch PROC
;;;180    
;;;181    status_t FT5406_GetMultiTouch(ft5406_handle_t *handle, int *touch_count, touch_point_t touch_array[FT5406_MAX_TOUCHES])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;182    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;183        status_t status;
;;;184    
;;;185        status = FT5406_ReadTouchData(handle);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FT5406_ReadTouchData
000010  4606              MOV      r6,r0
;;;186    
;;;187        if (status == kStatus_Success)
000012  2e00              CMP      r6,#0
000014  d164              BNE      |L2.224|
;;;188        {
;;;189            ft5406_touch_data_t *touch_data = (ft5406_touch_data_t *)(void *)(handle->touch_buf);
000016  f107011c          ADD      r1,r7,#0x1c
;;;190            int i;
;;;191    
;;;192            /* Decode number of touches */
;;;193            if (touch_count)
00001a  b10d              CBZ      r5,|L2.32|
;;;194            {
;;;195                *touch_count = touch_data->TD_STATUS;
00001c  784a              LDRB     r2,[r1,#1]
00001e  602a              STR      r2,[r5,#0]
                  |L2.32|
;;;196            }
;;;197    
;;;198            /* Decode valid touch points */
;;;199            for (i = 0; i < touch_data->TD_STATUS; i++)
000020  2000              MOVS     r0,#0
000022  e03f              B        |L2.164|
                  |L2.36|
;;;200            {
;;;201                touch_array[i].TOUCH_ID = TOUCH_POINT_GET_ID(touch_data->TOUCH[i]);
000024  eb000340          ADD      r3,r0,r0,LSL #1
000028  1c8a              ADDS     r2,r1,#2
00002a  eb020243          ADD      r2,r2,r3,LSL #1
00002e  7892              LDRB     r2,[r2,#2]
000030  1112              ASRS     r2,r2,#4
000032  eb000340          ADD      r3,r0,r0,LSL #1
000036  eb040343          ADD      r3,r4,r3,LSL #1
00003a  705a              STRB     r2,[r3,#1]
;;;202                touch_array[i].TOUCH_EVENT = TOUCH_POINT_GET_EVENT(touch_data->TOUCH[i]);
00003c  eb000340          ADD      r3,r0,r0,LSL #1
000040  1c8a              ADDS     r2,r1,#2
000042  f8122013          LDRB     r2,[r2,r3,LSL #1]
000046  1192              ASRS     r2,r2,#6
000048  eb000340          ADD      r3,r0,r0,LSL #1
00004c  f8042013          STRB     r2,[r4,r3,LSL #1]
;;;203                touch_array[i].TOUCH_X = TOUCH_POINT_GET_X(touch_data->TOUCH[i]);
000050  eb000340          ADD      r3,r0,r0,LSL #1
000054  1c8a              ADDS     r2,r1,#2
000056  eb020243          ADD      r2,r2,r3,LSL #1
00005a  7853              LDRB     r3,[r2,#1]
00005c  eb000c40          ADD      r12,r0,r0,LSL #1
000060  1c8a              ADDS     r2,r1,#2
000062  f812201c          LDRB     r2,[r2,r12,LSL #1]
000066  f002020f          AND      r2,r2,#0xf
00006a  ea432202          ORR      r2,r3,r2,LSL #8
00006e  eb000340          ADD      r3,r0,r0,LSL #1
000072  eb040343          ADD      r3,r4,r3,LSL #1
000076  805a              STRH     r2,[r3,#2]
;;;204                touch_array[i].TOUCH_Y = TOUCH_POINT_GET_Y(touch_data->TOUCH[i]);
000078  eb000340          ADD      r3,r0,r0,LSL #1
00007c  1c8a              ADDS     r2,r1,#2
00007e  eb020243          ADD      r2,r2,r3,LSL #1
000082  78d3              LDRB     r3,[r2,#3]
000084  eb000c40          ADD      r12,r0,r0,LSL #1
000088  1c8a              ADDS     r2,r1,#2
00008a  eb02024c          ADD      r2,r2,r12,LSL #1
00008e  7892              LDRB     r2,[r2,#2]
000090  f002020f          AND      r2,r2,#0xf
000094  ea432202          ORR      r2,r3,r2,LSL #8
000098  eb000340          ADD      r3,r0,r0,LSL #1
00009c  eb040343          ADD      r3,r4,r3,LSL #1
0000a0  809a              STRH     r2,[r3,#4]
0000a2  1c40              ADDS     r0,r0,#1              ;199
                  |L2.164|
0000a4  784a              LDRB     r2,[r1,#1]            ;199
0000a6  4282              CMP      r2,r0                 ;199
0000a8  dcbc              BGT      |L2.36|
;;;205            }
;;;206    
;;;207            /* Clear vacant elements of touch_array */
;;;208            for (; i < FT5406_MAX_TOUCHES; i++)
0000aa  e016              B        |L2.218|
                  |L2.172|
;;;209            {
;;;210                touch_array[i].TOUCH_ID = 0;
0000ac  2200              MOVS     r2,#0
0000ae  eb000340          ADD      r3,r0,r0,LSL #1
0000b2  eb040343          ADD      r3,r4,r3,LSL #1
0000b6  705a              STRB     r2,[r3,#1]
;;;211                touch_array[i].TOUCH_EVENT = kTouch_Reserved;
0000b8  2203              MOVS     r2,#3
0000ba  eb000340          ADD      r3,r0,r0,LSL #1
0000be  f8042013          STRB     r2,[r4,r3,LSL #1]
;;;212                touch_array[i].TOUCH_X = 0;
0000c2  2200              MOVS     r2,#0
0000c4  eb000340          ADD      r3,r0,r0,LSL #1
0000c8  eb040343          ADD      r3,r4,r3,LSL #1
0000cc  805a              STRH     r2,[r3,#2]
;;;213                touch_array[i].TOUCH_Y = 0;
0000ce  eb000340          ADD      r3,r0,r0,LSL #1
0000d2  eb040343          ADD      r3,r4,r3,LSL #1
0000d6  809a              STRH     r2,[r3,#4]
0000d8  1c40              ADDS     r0,r0,#1              ;208
                  |L2.218|
0000da  2805              CMP      r0,#5                 ;208
0000dc  d3e6              BCC      |L2.172|
;;;214            }
;;;215        }
0000de  bf00              NOP      
                  |L2.224|
;;;216    
;;;217        return status;
0000e0  4630              MOV      r0,r6
;;;218    }
0000e2  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.FT5406_GetSingleTouch||, CODE, READONLY, ALIGN=1

                  FT5406_GetSingleTouch PROC
;;;146    
;;;147    status_t FT5406_GetSingleTouch(ft5406_handle_t *handle, touch_event_t *touch_event, int *touch_x, int *touch_y)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;148    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;149        status_t status;
;;;150        touch_event_t touch_event_local;
;;;151    
;;;152        status = FT5406_ReadTouchData(handle);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FT5406_ReadTouchData
000012  4607              MOV      r7,r0
;;;153    
;;;154        if (status == kStatus_Success)
000014  b9e7              CBNZ     r7,|L3.80|
;;;155        {
;;;156            ft5406_touch_data_t *touch_data = (ft5406_touch_data_t *)(void *)(handle->touch_buf);
000016  f108001c          ADD      r0,r8,#0x1c
;;;157    
;;;158            if (touch_event == NULL)
00001a  b904              CBNZ     r4,|L3.30|
;;;159            {
;;;160                touch_event = &touch_event_local;
00001c  466c              MOV      r4,sp
                  |L3.30|
;;;161            }
;;;162            *touch_event = TOUCH_POINT_GET_EVENT(touch_data->TOUCH[0]);
00001e  7881              LDRB     r1,[r0,#2]
000020  1189              ASRS     r1,r1,#6
000022  7021              STRB     r1,[r4,#0]
;;;163    
;;;164            /* Update coordinates only if there is touch detected */
;;;165            if ((*touch_event == kTouch_Down) || (*touch_event == kTouch_Contact))
000024  7821              LDRB     r1,[r4,#0]
000026  b111              CBZ      r1,|L3.46|
000028  7821              LDRB     r1,[r4,#0]
00002a  2902              CMP      r1,#2
00002c  d10f              BNE      |L3.78|
                  |L3.46|
;;;166            {
;;;167                if (touch_x)
00002e  b135              CBZ      r5,|L3.62|
;;;168                {
;;;169                    *touch_x = TOUCH_POINT_GET_X(touch_data->TOUCH[0]);
000030  78c1              LDRB     r1,[r0,#3]
000032  7882              LDRB     r2,[r0,#2]
000034  f002020f          AND      r2,r2,#0xf
000038  ea412102          ORR      r1,r1,r2,LSL #8
00003c  6029              STR      r1,[r5,#0]
                  |L3.62|
;;;170                }
;;;171                if (touch_y)
00003e  b136              CBZ      r6,|L3.78|
;;;172                {
;;;173                    *touch_y = TOUCH_POINT_GET_Y(touch_data->TOUCH[0]);
000040  7942              LDRB     r2,[r0,#5]
000042  7901              LDRB     r1,[r0,#4]
000044  f001010f          AND      r1,r1,#0xf
000048  ea422101          ORR      r1,r2,r1,LSL #8
00004c  6031              STR      r1,[r6,#0]
                  |L3.78|
;;;174                }
;;;175            }
;;;176        }
00004e  bf00              NOP      
                  |L3.80|
;;;177    
;;;178        return status;
000050  4638              MOV      r0,r7
;;;179    }
000052  e8bd83f8          POP      {r3-r9,pc}
;;;180    
                          ENDP


                          AREA ||i.FT5406_Init||, CODE, READONLY, ALIGN=2

                  FT5406_Init PROC
;;;59     
;;;60     status_t FT5406_Init(ft5406_handle_t *handle, I2C_Type *base)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;61     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;62         i2c_master_transfer_t *xfer = &(handle->xfer);
000008  1d2c              ADDS     r4,r5,#4
;;;63         status_t status;
;;;64         uint8_t mode;
;;;65     
;;;66         assert(handle);
00000a  b105              CBZ      r5,|L4.14|
00000c  e004              B        |L4.24|
                  |L4.14|
00000e  2242              MOVS     r2,#0x42
000010  a12d              ADR      r1,|L4.200|
000012  a033              ADR      r0,|L4.224|
000014  f7fffffe          BL       __aeabi_assert
                  |L4.24|
;;;67         assert(base);
000018  b106              CBZ      r6,|L4.28|
00001a  e004              B        |L4.38|
                  |L4.28|
00001c  2243              MOVS     r2,#0x43
00001e  a12a              ADR      r1,|L4.200|
000020  a031              ADR      r0,|L4.232|
000022  f7fffffe          BL       __aeabi_assert
                  |L4.38|
;;;68     
;;;69     	 i2c_master_config_t masterConfig;
;;;70     
;;;71         I2C_MasterGetDefaultConfig(&masterConfig);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       I2C_MasterGetDefaultConfig
;;;72     
;;;73         /* Change the default baudrate configuration */
;;;74         masterConfig.baudRate_Bps = 100000;
00002c  4830              LDR      r0,|L4.240|
00002e  9001              STR      r0,[sp,#4]
;;;75     
;;;76     	 CLOCK_AttachClk(kFRO12M_to_FLEXCOMM2);
000030  f44f7087          MOV      r0,#0x10e
000034  f7fffffe          BL       CLOCK_AttachClk
;;;77     	
;;;78         /* Initialize the I2C master peripheral */
;;;79         I2C_MasterInit(base, &masterConfig, 12000000);
000038  4a2e              LDR      r2,|L4.244|
00003a  4669              MOV      r1,sp
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       I2C_MasterInit
;;;80     	
;;;81         if (!handle || !base)
000042  b105              CBZ      r5,|L4.70|
000044  b91e              CBNZ     r6,|L4.78|
                  |L4.70|
;;;82         {
;;;83             return kStatus_InvalidArgument;
000046  2004              MOVS     r0,#4
                  |L4.72|
;;;84         }
;;;85     
;;;86         handle->base = base;
;;;87     
;;;88         /* clear transfer structure and buffer */
;;;89         memset(xfer, 0, sizeof(*xfer));
;;;90         memset(handle->touch_buf, 0, FT5406_TOUCH_DATA_LEN);
;;;91     
;;;92         /* set device mode to normal operation */
;;;93         mode = 0;
;;;94         xfer->slaveAddress = 0x38;
;;;95         xfer->direction = kI2C_Write;
;;;96         xfer->subaddress = 0;
;;;97         xfer->subaddressSize = 1;
;;;98         xfer->data = &mode;
;;;99         xfer->dataSize = 1;
;;;100        xfer->flags = kI2C_TransferDefaultFlag;
;;;101    
;;;102        status = I2C_MasterTransferBlocking(handle->base, &handle->xfer);
;;;103    
;;;104        /* prepare transfer structure for reading touch data */
;;;105        xfer->slaveAddress = 0x38;
;;;106        xfer->direction = kI2C_Read;
;;;107        xfer->subaddress = 1;
;;;108        xfer->subaddressSize = 1;
;;;109        xfer->data = handle->touch_buf;
;;;110        xfer->dataSize = FT5406_TOUCH_DATA_LEN;
;;;111        xfer->flags = kI2C_TransferDefaultFlag;
;;;112    
;;;113    	// Set the wakeup pin to high
;;;114    
;;;115    		GPIO->DIR[2] |= 1<<27;
;;;116        GPIO_WritePinOutput(GPIO, 2, 27, 1);
;;;117    		
;;;118    		
;;;119        return status;
;;;120    }
000048  b004              ADD      sp,sp,#0x10
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.78|
00004e  602e              STR      r6,[r5,#0]            ;86
000050  2118              MOVS     r1,#0x18              ;89
000052  4620              MOV      r0,r4                 ;89
000054  f7fffffe          BL       __aeabi_memclr4
000058  2120              MOVS     r1,#0x20              ;90
00005a  f105001c          ADD      r0,r5,#0x1c           ;90
00005e  f7fffffe          BL       __aeabi_memclr4
000062  2000              MOVS     r0,#0                 ;93
000064  9003              STR      r0,[sp,#0xc]          ;93
000066  2038              MOVS     r0,#0x38              ;94
000068  80a0              STRH     r0,[r4,#4]            ;94
00006a  2000              MOVS     r0,#0                 ;95
00006c  71a0              STRB     r0,[r4,#6]            ;95
00006e  60a0              STR      r0,[r4,#8]            ;96
000070  2001              MOVS     r0,#1                 ;97
000072  60e0              STR      r0,[r4,#0xc]          ;97
000074  a803              ADD      r0,sp,#0xc            ;98
000076  6120              STR      r0,[r4,#0x10]         ;98
000078  2001              MOVS     r0,#1                 ;99
00007a  6160              STR      r0,[r4,#0x14]         ;99
00007c  2000              MOVS     r0,#0                 ;100
00007e  6020              STR      r0,[r4,#0]            ;100
000080  1d29              ADDS     r1,r5,#4              ;102
000082  6828              LDR      r0,[r5,#0]            ;102
000084  f7fffffe          BL       I2C_MasterTransferBlocking
000088  4607              MOV      r7,r0                 ;102
00008a  2038              MOVS     r0,#0x38              ;105
00008c  80a0              STRH     r0,[r4,#4]            ;105
00008e  2001              MOVS     r0,#1                 ;106
000090  71a0              STRB     r0,[r4,#6]            ;106
000092  60a0              STR      r0,[r4,#8]            ;107
000094  60e0              STR      r0,[r4,#0xc]          ;108
000096  f105001c          ADD      r0,r5,#0x1c           ;109
00009a  6120              STR      r0,[r4,#0x10]         ;109
00009c  2020              MOVS     r0,#0x20              ;110
00009e  6160              STR      r0,[r4,#0x14]         ;110
0000a0  2000              MOVS     r0,#0                 ;111
0000a2  6020              STR      r0,[r4,#0]            ;111
0000a4  4814              LDR      r0,|L4.248|
0000a6  6880              LDR      r0,[r0,#8]            ;115
0000a8  f0406100          ORR      r1,r0,#0x8000000      ;115
0000ac  4812              LDR      r0,|L4.248|
0000ae  6081              STR      r1,[r0,#8]            ;115
0000b0  4812              LDR      r0,|L4.252|
0000b2  2102              MOVS     r1,#2                 ;116
0000b4  221b              MOVS     r2,#0x1b              ;116
0000b6  2301              MOVS     r3,#1                 ;116
0000b8  eb001c41          ADD      r12,r0,r1,LSL #5      ;116
0000bc  f80c3002          STRB     r3,[r12,r2]           ;116
0000c0  bf00              NOP                            ;116
0000c2  4638              MOV      r0,r7                 ;119
0000c4  e7c0              B        |L4.72|
;;;121    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L4.200|
0000c8  5352435c          DCB      "SRC\\System\\fsl_ft5406.c",0
0000cc  53797374
0000d0  656d5c66
0000d4  736c5f66
0000d8  74353430
0000dc  362e6300
                  |L4.224|
0000e0  68616e64          DCB      "handle",0
0000e4  6c6500  
0000e7  00                DCB      0
                  |L4.232|
0000e8  62617365          DCB      "base",0
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L4.240|
                          DCD      0x000186a0
                  |L4.244|
                          DCD      0x00b71b00
                  |L4.248|
                          DCD      0x4008e000
                  |L4.252|
                          DCD      0x4008c000

                          AREA ||i.FT5406_ReadTouchData||, CODE, READONLY, ALIGN=2

                  FT5406_ReadTouchData PROC
;;;134    
;;;135    status_t FT5406_ReadTouchData(ft5406_handle_t *handle)
000000  b510              PUSH     {r4,lr}
;;;136    {
000002  4604              MOV      r4,r0
;;;137        assert(handle);
000004  b104              CBZ      r4,|L5.8|
000006  e004              B        |L5.18|
                  |L5.8|
000008  2289              MOVS     r2,#0x89
00000a  a106              ADR      r1,|L5.36|
00000c  a00b              ADR      r0,|L5.60|
00000e  f7fffffe          BL       __aeabi_assert
                  |L5.18|
;;;138    
;;;139        if (!handle)
000012  b90c              CBNZ     r4,|L5.24|
;;;140        {
;;;141            return kStatus_InvalidArgument;
000014  2004              MOVS     r0,#4
                  |L5.22|
;;;142        }
;;;143    
;;;144        return I2C_MasterTransferBlocking(handle->base, &handle->xfer);
;;;145    }
000016  bd10              POP      {r4,pc}
                  |L5.24|
000018  1d21              ADDS     r1,r4,#4              ;144
00001a  6820              LDR      r0,[r4,#0]            ;144
00001c  f7fffffe          BL       I2C_MasterTransferBlocking
000020  e7f9              B        |L5.22|
;;;146    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
000024  5352435c          DCB      "SRC\\System\\fsl_ft5406.c",0
000028  53797374
00002c  656d5c66
000030  736c5f66
000034  74353430
000038  362e6300
                  |L5.60|
00003c  68616e64          DCB      "handle",0
000040  6c6500  
000043  00                DCB      0

;*** Start embedded assembler ***

#line 1 "SRC\\System\\fsl_ft5406.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ft5406_c_07a511c6____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_fsl_ft5406_c_07a511c6____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ft5406_c_07a511c6____REVSH|
#line 402
|__asm___12_fsl_ft5406_c_07a511c6____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ft5406_c_07a511c6____RRX|
#line 587
|__asm___12_fsl_ft5406_c_07a511c6____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
